<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trái Tim</title>
    <style>
        body { overflow: hidden; margin: 0; background-color: #000; }
        #word {
            font-family: sans-serif;
            position: absolute;
            width: 100%;
            text-align: center;
            top: 8%;
            color: white;
            font-weight: bold;
            letter-spacing: 5px;
            text-shadow: 0 0 10px rgba(255,255,255,0.8);
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="word">Lợn thúi</div>

    <script type="module">
        import * as THREE from "https://cdn.skypack.dev/three@0.136.0";
        import { OrbitControls } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls";

        let scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        
        let camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 45); // Đặt camera thẳng mặt

        let renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const imageUrl = 'https://sf-static.upanhlaylink.com/img/image_202601156eb379ca56737ac995836d81fcc27977.jpg';
        const textureLoader = new THREE.TextureLoader();
        textureLoader.setCrossOrigin('anonymous');
        const particleTexture = textureLoader.load(imageUrl); 

        let controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 0, 0);

        let gu = { time: { value: 0 } };

        function createMaterial() {
            return new THREE.PointsMaterial({
                size: 0.45, 
                map: particleTexture,
                transparent: true,
                depthTest: true, 
                alphaTest: 0.2, // Giảm alphaTest
                blending: THREE.NormalBlending, 
                onBeforeCompile: shader => {
                    shader.uniforms.time = gu.time;
                    shader.vertexShader = `
                        uniform float time;
                        attribute float sizes;
                        attribute vec4 shift;
                        ${shader.vertexShader}
                    `.replace(
                        `gl_PointSize = size;`,
                        `gl_PointSize = size * sizes;`
                    ).replace(
                        `#include <begin_vertex>`,
                        `#include <begin_vertex>
                        float t = time;
                        float moveT = mod(shift.x + shift.z * t, PI2);
                        float moveS = mod(shift.y + shift.z * t, PI2);
                        transformed += vec3(cos(moveS) * sin(moveT), cos(moveT), sin(moveS) * sin(moveT)) * shift.a;
                        `
                    );
                }
            });
        }

        // 1. TRÁI TIM CÂN TÂM
        let heartPts = [];
        let heartSizes = [];
        let heartShift = [];
        for (let i = 0; i < 150000; i++) {
            let x = (Math.random() - 0.5) * 3.5;
            let y = (Math.random() - 0.5) * 3.5;
            let z = (Math.random() - 0.5) * 3.5;
            if ((Math.pow(x*x + 2.25*y*y + z*z - 1, 3) - x*x*z*z*z - 0.1125*y*y*z*z*z) < 0) {
                // Tọa độ đã được tính toán để tập trung quanh (0,0,0)
                heartPts.push(new THREE.Vector3(x * 12, y * 12, z * 12));
                heartSizes.push(Math.random() * 1.5 + 0.5);
                heartShift.push(Math.random() * Math.PI, Math.random() * Math.PI * 2, (Math.random() * 0.9 + 0.1) * Math.PI * 0.1, Math.random() * 0.15);
            }
        }
        let heartGeo = new THREE.BufferGeometry().setFromPoints(heartPts);
        heartGeo.setAttribute("sizes", new THREE.Float32BufferAttribute(heartSizes, 1));
        heartGeo.setAttribute("shift", new THREE.Float32BufferAttribute(heartShift, 4));
        let heartObj = new THREE.Points(heartGeo, createMaterial());
        
        // Để trái tim đứng thẳng 
        heartObj.rotation.x = -Math.PI / 2;
        
        // Dùng một Group để quản lý việc xoay
        let mainGroup = new THREE.Group();
        mainGroup.add(heartObj);
        scene.add(mainGroup);

        // 2. VÀNH ĐAI CHÉO CÂN TÂM
        let ringPts = [];
        let ringSizes = [];
        let ringShift = [];
        const ringRadiusInner = 17; 
        const ringWidth = 4;
        
        for (let i = 0; i < 20000; i++) {
            let angle = Math.random() * Math.PI * 2;
            let distance = ringRadiusInner + Math.random() * ringWidth; 
            let x = Math.cos(angle) * distance;
            let z = Math.sin(angle) * distance;
            let y = (Math.random() - 0.5) * 0.15;

            ringPts.push(new THREE.Vector3(x, y, z));
            ringSizes.push(Math.random() * 0.7 + 0.3);
            ringShift.push(Math.random() * Math.PI, Math.random() * Math.PI * 2, (Math.random() * 0.9 + 0.1) * Math.PI * 0.1, Math.random() * 0.08);
        }
        let ringGeo = new THREE.BufferGeometry().setFromPoints(ringPts);
        ringGeo.setAttribute("sizes", new THREE.Float32BufferAttribute(ringSizes, 1));
        ringGeo.setAttribute("shift", new THREE.Float32BufferAttribute(ringShift, 4));
        let ringObj = new THREE.Points(ringGeo, createMaterial());
        
        // Nghiêng chéo vành đai
        ringObj.rotation.z = 0.5; 
        ringObj.rotation.x = 0.2; 
        mainGroup.add(ringObj);

        let clock = new THREE.Clock();
        renderer.setAnimationLoop(() => {
            controls.update();
            let t = clock.getElapsedTime();
            gu.time.value = t;
            
            // Xoay toàn bộ Group quanh trục đứng của thế giới
            mainGroup.rotation.y = t * 0.2;
            
            // Nếu muốn trái tim tự xoay thêm bên trong
            heartObj.rotation.z = t * 0.1;
            
            renderer.render(scene, camera);
        });

        window.addEventListener("resize", () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });
    </script>
</body>
</html>